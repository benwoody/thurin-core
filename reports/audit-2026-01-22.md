# Thurin Circuit Security Audit Report

**Date:** 2026-01-22
**Auditor:** Claude Code Security Audit
**Commit:** 63c8b49 (Initial monorepo setup)
**Noir Version:** >=0.36.0

---

## 1. Executive Summary

### Scope

This audit covers the Thurin zero-knowledge mDL (mobile driver's license) verification circuit, which allows users to prove claims about their driver's license (age over 21/18, issuing jurisdiction) without revealing personal information.

| Metric | Value |
|--------|-------|
| Circuit Files | 5 (main.nr, cbor.nr, mso.nr, nullifier.nr, utils.nr) |
| Helper Files | 1 (circuits-helper/src/main.nr) |
| ACIR Opcodes | 1376 |
| Expression Width | 1929 |
| Test Count | 17 (all passing) |

### Findings Summary

| Severity | Count |
|----------|-------|
| Critical | 1 |
| High | 2 |
| Medium | 3 |
| Low | 2 |
| Informational | 3 |

### Overall Assessment

The Thurin circuit implements a sophisticated mDL verification system with good architectural decisions around nullifier derivation and claim verification. However, **the circuit contains a critical issue** where the `bound_address` public input is completely unused, allowing proof theft/front-running. Additionally, there are high-severity concerns around missing domain separation in hash operations and an inadequate timestamp conversion that could lead to incorrect expiry validation.

**Recommendation:** Do not deploy to mainnet until Critical and High severity issues are addressed.

---

## 2. Circuit Overview

### What the Circuit Proves

The Thurin circuit proves that a user holds a valid mobile driver's license (mDL) issued by a recognized Issuer Authority Certificate Authority (IACA) with specific claims (age over 21, age over 18, or issuing jurisdiction), without revealing the document itself.

### Public Inputs (Revealed On-Chain)

| Input | Type | Purpose |
|-------|------|---------|
| `nullifier` | Field | Prevents double-spending/sybil attacks per event |
| `proof_timestamp` | u64 | Time of proof generation for expiry check |
| `event_id` | Field | Unique event identifier bound to nullifier |
| `iaca_root` | Field | Merkle root/hash of trusted IACA public key |
| `bound_address` | Field | Wallet address proof should be bound to (UNUSED) |
| `prove_age_over_21` | bool | Flag to verify age >= 21 |
| `prove_age_over_18` | bool | Flag to verify age >= 18 |
| `prove_state` | bool | Flag to verify issuing jurisdiction |
| `proven_state` | [u8; 2] | Expected 2-char state code (if prove_state=true) |

### Private Inputs (Never Revealed)

| Input | Type | Purpose |
|-------|------|---------|
| `age_over_21_claim_bytes` | [u8; 96] | CBOR-encoded age_over_21 claim |
| `age_over_18_claim_bytes` | [u8; 96] | CBOR-encoded age_over_18 claim |
| `state_claim_bytes` | [u8; 107] | CBOR-encoded state/jurisdiction claim |
| `mso_bytes` | [u8; 512] | Mobile Security Object containing digests |
| `mso_signature` | [u8; 64] | ECDSA P-256 signature over MSO |
| `document_number` | [u8; 32] | Unique document identifier for nullifier |
| `iaca_pubkey_x` | [u8; 32] | IACA public key X coordinate |
| `iaca_pubkey_y` | [u8; 32] | IACA public key Y coordinate |

### Cryptographic Primitives

- **SHA-256**: Used for MSO hashing and claim digest verification
- **ECDSA secp256r1 (P-256)**: MSO signature verification
- **Poseidon2**: Nullifier and IACA root computation

---

## 3. Assumptions & Trust Model

### Trusted Components

1. **IACA Public Keys**: The circuit trusts that the provided `iaca_root` corresponds to a legitimate certificate authority
2. **MSO Structure**: Fixed offsets assume specific CBOR structure; malformed MSOs may cause incorrect parsing
3. **Verifier Contract**: Assumes the on-chain verifier correctly validates the `iaca_root` against a whitelist

### Out of Scope

1. On-chain verifier contract implementation
2. IACA certificate chain validation
3. mDL credential issuance process
4. SDK/frontend implementation

### Limitations

1. Fixed CBOR offsets limit flexibility to specific mDL formats
2. Simplified timestamp conversion may have edge-case errors (see findings)
3. No support for multiple namespaces or additional claim types

---

## 4. Findings Summary Table

| ID | Title | Severity | Status | Category |
|----|-------|----------|--------|----------|
| THU-01 | bound_address Public Input Completely Unused | Critical | Open | ZK-UC |
| THU-02 | Missing Domain Separation in Poseidon2 Hashes | High | Open | ZK-DS |
| THU-03 | Inaccurate Timestamp Conversion May Cause Expiry Bypass | High | Open | ZK-MC |
| THU-04 | No Verification That Claimed Proof Flags Are Meaningful | Medium | Open | ZK-UC |
| THU-05 | State Code Not Validated as Valid US State | Medium | Open | ZK-MC |
| THU-06 | MSO Digest Index Mismatch in Documentation | Medium | Open | ZK-MC |
| THU-07 | No Event ID Uniqueness Enforcement | Low | Open | ZK-NB |
| THU-08 | Fixed Array Sizes May Reject Valid Documents | Low | Open | ZK-OC |
| THU-09 | bytes32_eq Uses Early-Exit Boolean Pattern | Info | Open | Code Quality |
| THU-10 | Unused Imports and Dead Code Potential | Info | Open | Code Quality |
| THU-11 | Missing Negative Test Cases | Info | Open | Test Coverage |

---

## 5. Detailed Findings

### THU-01: bound_address Public Input Completely Unused

**Severity:** Critical
**Category:** ZK-UC (Underconstrained)
**Location:** `/Users/benwoodall/Development/thurin/thurin-core/circuits/src/main.nr:26`

#### Description

The `bound_address` parameter is declared as a public input but is never used in any constraint within the circuit:

```rust
fn main(
    // ...
    _bound_address: pub Field, // Wallet address this proof is bound to
    // ...
) {
    // bound_address is NEVER referenced in the function body
}
```

The underscore prefix (`_bound_address`) indicates the developer was aware this input is unused.

#### Impact

**Soundness Break / Authorization Bypass**

Without binding the proof to a specific address:

1. **Proof Theft**: Anyone who observes a valid proof in the mempool can front-run the transaction and claim the proof as their own
2. **Replay Attacks**: A proof generated for wallet A can be submitted by wallet B
3. **Sybil Attacks**: Combined with public event_id, the same document holder could generate multiple proofs for different addresses

This completely undermines the purpose of having address binding as a public input.

#### Proof of Concept

1. Alice generates a proof with `bound_address = 0xAlice`
2. Alice broadcasts transaction containing the proof
3. Bob observes the transaction in the mempool
4. Bob extracts the proof and submits it with his own transaction
5. Since `bound_address` is not constrained, Bob's transaction succeeds
6. Alice's transaction may fail due to nullifier already being used, or Bob gains unauthorized access

#### Remediation

The nullifier must include the bound address to create a cryptographic binding:

```rust
// In main.nr, the nullifier computation should include bound_address:
let computed_nullifier = compute_nullifier(document_number, event_id, iaca_root, bound_address);
assert(computed_nullifier == nullifier);

// In nullifier.nr:
pub fn compute_nullifier(
    document_number: [u8; 32],
    event_id: Field,
    iaca_root: Field,
    bound_address: Field,  // ADD THIS
) -> Field {
    let doc_hash = bytes32_to_field(document_number);
    Poseidon2::hash([doc_hash, event_id, iaca_root, bound_address], 4)  // Include address
}
```

#### Verification Test

```rust
#[test(should_fail)]
fn test_proof_not_reusable_for_different_address() {
    // Generate proof with bound_address = 0x1
    // Verify proof fails if verifier expects bound_address = 0x2
}
```

---

### THU-02: Missing Domain Separation in Poseidon2 Hashes

**Severity:** High
**Category:** ZK-DS (Missing Domain Separation)
**Location:** `/Users/benwoodall/Development/thurin/thurin-core/circuits/src/nullifier.nr:18-34`

#### Description

Both `compute_iaca_root` and `compute_nullifier` use Poseidon2 hashing without domain separation prefixes:

```rust
pub fn compute_iaca_root(pubkey_x: [u8; 32], pubkey_y: [u8; 32]) -> Field {
    let x_field = bytes32_to_field(pubkey_x);
    let y_field = bytes32_to_field(pubkey_y);
    Poseidon2::hash([x_field, y_field], 2)  // No domain separator
}

pub fn compute_nullifier(
    document_number: [u8; 32],
    event_id: Field,
    iaca_root: Field,
) -> Field {
    let doc_hash = bytes32_to_field(document_number);
    Poseidon2::hash([doc_hash, event_id, iaca_root], 3)  // No domain separator
}
```

#### Impact

Without domain separation, there is a theoretical risk of hash collisions across different contexts:

1. If `iaca_root` computation produces a value that could also be a valid nullifier input, cross-context attacks become possible
2. Future protocol changes adding new hash operations could inadvertently collide with existing hashes
3. Interoperability with other systems using the same Poseidon2 parameters could lead to unexpected collisions

While exploitation requires specific input crafting, this violates cryptographic best practices and represents a latent vulnerability.

#### Remediation

Add domain separation constants to each hash operation:

```rust
// Define domain separators
global DOMAIN_IACA_ROOT: Field = 0x01;
global DOMAIN_NULLIFIER: Field = 0x02;

pub fn compute_iaca_root(pubkey_x: [u8; 32], pubkey_y: [u8; 32]) -> Field {
    let x_field = bytes32_to_field(pubkey_x);
    let y_field = bytes32_to_field(pubkey_y);
    Poseidon2::hash([DOMAIN_IACA_ROOT, x_field, y_field], 3)
}

pub fn compute_nullifier(
    document_number: [u8; 32],
    event_id: Field,
    iaca_root: Field,
) -> Field {
    let doc_hash = bytes32_to_field(document_number);
    Poseidon2::hash([DOMAIN_NULLIFIER, doc_hash, event_id, iaca_root], 4)
}
```

#### Verification Test

```rust
#[test]
fn test_domain_separation_prevents_collision() {
    // Construct inputs that would collide without domain separation
    // Verify they produce different outputs with domain separation
}
```

---

### THU-03: Inaccurate Timestamp Conversion May Cause Expiry Bypass

**Severity:** High
**Category:** ZK-MC (Missing Constraint)
**Location:** `/Users/benwoodall/Development/thurin/thurin-core/circuits/src/utils.nr:17-51`

#### Description

The `timestamp_to_yyyymmdd` function uses simplified arithmetic that can produce incorrect dates:

```rust
pub fn timestamp_to_yyyymmdd(timestamp: u64) -> u32 {
    // Approximate years since 2020 (using 365 days, close enough for expiry)
    let years_since_2020 = days_since_2020 / 365;  // Ignores leap years

    // Approximate month and day (simplified 30-day months)
    let month = (day_of_year / 30) + 1;  // All months treated as 30 days
    let day = (day_of_year % 30) + 1;

    // Clamp month to 1-12 and day to 1-28
    let month_clamped = if month > 12 { 12 } else { month };
    let day_clamped = if day > 28 { 28 } else { day };
    // ...
}
```

#### Impact

The approximation errors accumulate:

1. **Leap Year Error**: ~1 day error every 4 years, accumulating to ~1.5 days by 2026
2. **Month Length Error**: Using 30-day months means dates like Dec 31 (day 365) become approximately month 13 (clamped to 12), day 6
3. **Accumulated Error**: For timestamps in late December, the computed date could be off by several days

**Example Attack Vector:**
- MSO expires on 2026-01-02 (YYYYMMDD = 20260102)
- Actual current date: 2026-01-05
- Computed current date due to errors: 20260101 (appears earlier)
- Check `20260102 >= 20260101` passes, but document IS expired

This could allow proofs to be generated for expired documents.

#### Remediation

Option 1: Pass `proof_date` as a public input (recommended for production):

```rust
fn main(
    // ...
    proof_date: pub u32,  // YYYYMMDD format, verified off-chain
    // ...
) {
    // Verifier contract ensures proof_date is close to block.timestamp
    let mso_expiry = extract_mso_valid_until(mso_bytes);
    assert(mso_expiry >= proof_date);
}
```

Option 2: Use a more accurate conversion with leap year handling (complex, increases constraints).

#### Verification Test

```rust
#[test]
fn test_timestamp_accuracy_for_edge_cases() {
    // Test late December dates
    // Test leap year boundaries
    // Verify error is within acceptable bounds
}
```

---

### THU-04: No Verification That Claimed Proof Flags Are Meaningful

**Severity:** Medium
**Category:** ZK-UC (Underconstrained)
**Location:** `/Users/benwoodall/Development/thurin/thurin-core/circuits/src/main.nr:85-100`

#### Description

The circuit allows users to set proof flags to `false` without any enforcement that they are providing meaningful proofs:

```rust
// 6. Extract and verify age_over_21
let is_over_21 = extract_age_over_21(age_over_21_claim_bytes);
if prove_age_over_21 {
    assert(is_over_21); // Must be true if proving
}
// BUT: if prove_age_over_21 = false, is_over_21 could be false (under 21)

// 7. Extract and verify age_over_18
let is_over_18 = extract_age_over_18(age_over_18_claim_bytes);
if prove_age_over_18 {
    assert(is_over_18); // Must be true if proving
}

// 8. Extract and verify state code
let state_code = extract_state_code(state_claim_bytes);
if prove_state {
    assert(state_code[0] == proven_state[0]);
    assert(state_code[1] == proven_state[1]);
}
```

#### Impact

A user could:
1. Set all proof flags to `false`
2. Generate a valid proof that proves nothing useful
3. The proof still passes all constraints (MSO signature, nullifier, etc.)

While this doesn't break soundness, it could confuse verifier contracts that expect proofs to always prove something meaningful.

#### Remediation

Require at least one proof flag to be true:

```rust
// At least one claim must be proven
assert(prove_age_over_21 | prove_age_over_18 | prove_state);
```

Or, the verifier contract should check the flags match expected claims.

---

### THU-05: State Code Not Validated as Valid US State

**Severity:** Medium
**Category:** ZK-MC (Missing Constraint)
**Location:** `/Users/benwoodall/Development/thurin/thurin-core/circuits/src/cbor.nr:33-36`

#### Description

The state code extraction simply reads two bytes without validating they represent a valid US state:

```rust
pub fn extract_state_code(claim: [u8; 107]) -> [u8; 2] {
    [claim[STATE_CODE_OFFSET], claim[STATE_CODE_OFFSET + 1]]
}
```

#### Impact

1. A crafted MSO could contain non-alphabetic bytes (e.g., `[0x00, 0xFF]`)
2. Invalid state codes like "ZZ" or "99" would be accepted
3. Verifier contracts must implement their own state validation

This is a defense-in-depth concern; the MSO is signed by the IACA, so invalid states shouldn't appear in legitimate documents.

#### Remediation

Add ASCII letter validation:

```rust
pub fn extract_state_code(claim: [u8; 107]) -> [u8; 2] {
    let code = [claim[STATE_CODE_OFFSET], claim[STATE_CODE_OFFSET + 1]];
    // Validate both bytes are uppercase ASCII letters (A-Z: 65-90)
    assert(code[0] >= 65 & code[0] <= 90);
    assert(code[1] >= 65 & code[1] <= 90);
    code
}
```

---

### THU-06: MSO Digest Index Mismatch in Documentation

**Severity:** Medium
**Category:** ZK-MC (Missing Constraint)
**Location:** `/Users/benwoodall/Development/thurin/thurin-core/circuits/src/mso.nr:5-8` and `/Users/benwoodall/Development/thurin/thurin-core/circuits/src/main.nr:34-40`

#### Description

There is a mismatch between the comments and the actual digest usage:

In `mso.nr`:
```rust
pub global MSO_DIGEST_0_OFFSET: u32 = 143;  // digestID 0 (age_over_21)
pub global MSO_DIGEST_1_OFFSET: u32 = 179;  // digestID 1 (state)
pub global MSO_DIGEST_2_OFFSET: u32 = 215;  // digestID 2 (age_over_18)
```

In `main.nr`:
```rust
// Age over 21 claim (digestID=0 at MSO offset 143)
age_over_21_claim_bytes: [u8; 96],

// Age over 18 claim (digestID=2 at MSO offset 215)
age_over_18_claim_bytes: [u8; 96],

// State claim (digestID=1 at MSO offset 179)
state_claim_bytes: [u8; 107],
```

The code uses:
```rust
// age_over_21 -> MSO_DIGEST_0_OFFSET (correct)
// age_over_18 -> MSO_DIGEST_2_OFFSET (correct)
// state -> MSO_DIGEST_1_OFFSET (correct)
```

However, the Prover.toml shows:
```toml
# digest ID 0 = age_over_21 at offset 143
# digest ID 1 = state at offset 179
# digest ID 2 = age_over_18 at offset 215
```

But the actual MSO in Prover.toml has different digest order (0, 1, 2 mapped to different claims).

#### Impact

If the MSO structure changes or different IACA's use different orderings, proofs will fail silently or verify incorrect claims.

#### Remediation

Add runtime validation that the claim's `elementIdentifier` matches expected values, or document the exact MSO schema requirements.

---

### THU-07: No Event ID Uniqueness Enforcement

**Severity:** Low
**Category:** ZK-NB (Unbound Nullifier)
**Location:** `/Users/benwoodall/Development/thurin/thurin-core/circuits/src/main.nr:24`

#### Description

The `event_id` is used in nullifier computation but there's no constraint on its value:

```rust
event_id: pub Field,
```

#### Impact

- If the same `event_id` is reused across multiple events, nullifiers for different purposes could collide
- The circuit relies entirely on the off-chain system to ensure event ID uniqueness

This is primarily an integration concern rather than a circuit vulnerability.

#### Remediation

Document the requirement that `event_id` must be unique per event, and consider binding it to additional context (e.g., event organizer address, timestamp range).

---

### THU-08: Fixed Array Sizes May Reject Valid Documents

**Severity:** Low
**Category:** ZK-OC (Overconstrained)
**Location:** `/Users/benwoodall/Development/thurin/thurin-core/circuits/src/main.nr:35-44`

#### Description

The circuit uses fixed-size arrays for all inputs:

```rust
age_over_21_claim_bytes: [u8; 96],
age_over_18_claim_bytes: [u8; 96],
state_claim_bytes: [u8; 107],
mso_bytes: [u8; 512],
```

#### Impact

- mDL documents with different CBOR encoding lengths will be rejected
- Documents with more than 512 bytes of MSO data cannot be verified
- Different issuers may produce claims with different lengths

This limits compatibility but doesn't affect security of accepted proofs.

#### Remediation

Either:
1. Document supported mDL formats clearly
2. Use padded variable-length encoding with explicit length field
3. Support multiple claim sizes as separate circuit variants

---

### THU-09: bytes32_eq Uses Early-Exit Boolean Pattern

**Severity:** Informational
**Category:** Code Quality
**Location:** `/Users/benwoodall/Development/thurin/thurin-core/circuits/src/utils.nr:4-12`

#### Description

```rust
pub fn bytes32_eq(a: [u8; 32], b: [u8; 32]) -> bool {
    let mut eq = true;
    for i in 0..32 {
        if a[i] != b[i] {
            eq = false;
        }
    }
    eq
}
```

The function continues iterating even after finding a mismatch.

#### Impact

No security impact in ZK circuits (all paths generate the same constraints). Minor gas optimization opportunity.

#### Remediation (Optional)

The current implementation is actually correct for ZK circuits as it ensures constant-time execution. No change needed.

---

### THU-10: Unused Imports and Dead Code Potential

**Severity:** Informational
**Category:** Code Quality
**Location:** Various

#### Description

The `bound_address` parameter is prefixed with `_` indicating known unused variable. There may be other unused imports or code paths.

#### Remediation

Run `nargo check` with warnings enabled and address any unused variable/import warnings.

---

### THU-11: Missing Negative Test Cases

**Severity:** Informational
**Category:** Test Coverage
**Location:** Test files throughout

#### Description

The test suite includes 17 tests, all testing positive cases. Missing:

1. Tests for invalid CBOR encoding (non-boolean values at age offset)
2. Tests for MSO signature verification failure
3. Tests for expired MSO rejection
4. Tests for nullifier uniqueness across different inputs
5. Tests for invalid state codes

#### Remediation

Add `#[test(should_fail)]` tests for each negative case:

```rust
#[test(should_fail)]
fn test_reject_invalid_cbor_boolean() {
    let mut claim = [0u8; 96];
    claim[65] = 0x00; // Invalid: not 0xf4 or 0xf5
    let _ = extract_age_boolean(claim); // Should fail assertion
}

#[test(should_fail)]
fn test_reject_expired_mso() {
    // MSO with validUntil in the past
    // proof_timestamp in the future
    // Should fail expiry check
}
```

---

## 6. Verification Plan

### Tests to Add

1. **Negative Tests for All Assertions**
   - Invalid CBOR boolean values
   - Invalid ASCII digits in MSO dates
   - Mismatched claim hashes
   - Invalid ECDSA signatures
   - Expired MSO documents

2. **Boundary Tests**
   - Maximum field values in nullifier computation
   - Edge case timestamps (year boundaries, leap years)
   - Maximum/minimum valid state codes

3. **Integration Tests**
   - End-to-end proof generation and verification
   - Multiple documents from different IACAs
   - Different event IDs for same document

### Fuzzing Recommendations

1. **CBOR Parsing Fuzzing**: Generate random byte arrays and verify extraction functions either succeed with valid values or fail gracefully
2. **Timestamp Fuzzing**: Test timestamp conversion accuracy across wide range of dates
3. **Hash Collision Testing**: Generate many inputs to nullifier/IACA root functions to verify no unexpected collisions

### Monitoring Considerations

1. **Nullifier Tracking**: Monitor for duplicate nullifiers (indicates either double-spend attempt or collision)
2. **IACA Root Whitelist**: Maintain and update list of valid IACA public keys
3. **Proof Flag Distribution**: Track which claim combinations are most commonly proven
4. **Expiry Alerts**: Monitor for proofs generated close to document expiry

---

## 7. Appendix: Files Reviewed

| File | Lines | Purpose |
|------|-------|---------|
| `/circuits/Nargo.toml` | 10 | Project configuration |
| `/circuits/Prover.toml` | 40 | Test vector inputs |
| `/circuits/src/main.nr` | 438 | Main circuit entry point |
| `/circuits/src/cbor.nr` | 77 | CBOR claim extraction |
| `/circuits/src/mso.nr` | 109 | MSO digest/validity extraction |
| `/circuits/src/nullifier.nr` | 65 | Nullifier and IACA root computation |
| `/circuits/src/utils.nr` | 92 | Utility functions |
| `/circuits-helper/src/main.nr` | 50 | Helper for computing hashes |

---

## 8. Disclaimer

This audit was conducted based on the code available at commit `63c8b49`. The findings represent the auditor's assessment at the time of review. Smart contract and circuit security is a continuous process, and new vulnerabilities may be discovered after this audit. This report does not constitute financial or legal advice.

---

*Report generated by Claude Code Security Audit*
