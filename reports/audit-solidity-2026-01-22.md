# Smart Contract Security Audit Report - Solidity Contracts

**Project**: Thurin Identity Verification (thurin-core)
**Repository**: thurin-core (monorepo)
**Commit**: 63c8b498b776b8e13d5f131cd1ec85cf55f05162
**Auditor**: Claude Opus 4.5 (AI-Assisted Audit)
**Date**: 2026-01-22

---

## Executive Summary

### Scope

| Item | Details |
|------|---------|
| Contracts | ThurinSBT.sol, ThurinVerifier.sol, ThurinPoints.sol, HonkVerifier.sol |
| Lines of Code | ~917 (excluding auto-generated HonkVerifier) |
| Solidity Version | 0.8.28 |
| Framework | Foundry |
| Chain Target | Base Mainnet / Base Sepolia |

### Findings Summary

| Severity | Count |
|----------|-------|
| Critical | 0 |
| High | 0 |
| Medium | 3 |
| Low | 3 |
| Informational | 5 |
| **Total** | **11** |

### Overall Assessment

The Thurin Solidity contracts demonstrate a solid security architecture with appropriate use of OpenZeppelin contracts, proper access control through Ownable2Step, and correct soulbound token implementation. The ZK proof verification system is well-designed with front-running protection via address binding. The test suite is comprehensive with 82 passing tests including integration tests with real ZK proofs.

The most significant concerns are:
1. The `getTopDapps()` function presents a potential DoS vector due to unbounded gas consumption
2. The date calculation approximation, while documented, could cause edge-case issues near year boundaries
3. Overpayment in mint/renew is not refunded to users

All critical security patterns are correctly implemented: CEI pattern adherence, proper access control, soulbound transfer restrictions, and nullifier tracking for sybil resistance.

---

## Scope & Methodology

### In-Scope Contracts

| File | LOC | Description |
|------|-----|-------------|
| `contracts/src/ThurinSBT.sol` | 420 | Soulbound token with ZK proof minting |
| `contracts/src/ThurinVerifier.sol` | 132 | Stateless ZK proof verification for dApps |
| `contracts/src/ThurinPoints.sol` | 188 | Points tracking for users and dApps |
| `contracts/src/interfaces/*.sol` | 177 | Interface definitions |

### Out of Scope

- `HonkVerifier.sol` - Auto-generated cryptographic verifier (assumed correct per Noir/BB toolchain)
- Test files and deployment scripts
- External dependencies (OpenZeppelin, forge-std)
- Off-chain ZK circuit implementation (covered in separate circuit audit)

### Methodology

1. **Automated Analysis**: Foundry build verification, 82 passing tests including integration tests with real ZK proofs
2. **Manual Review**: Line-by-line code review following security checklist
3. **Threat Modeling**: Identification of attack vectors and trust assumptions
4. **Test Gap Analysis**: Review of existing test coverage

---

## Assumptions & Trust Model

### Trusted Entities

| Entity | Trust Level | Capabilities |
|--------|-------------|--------------|
| Owner (Ownable2Step) | Trusted | Add/remove IACA roots, set prices, withdraw funds |
| HonkVerifier | Trusted | ZK proof verification (auto-generated) |
| IACA Roots | Semi-trusted | Represent valid US state DMV public keys |

### Key Assumptions

1. The HonkVerifier contract correctly validates ZK proofs as generated by the Noir circuit
2. IACA roots added by the owner represent legitimate state DMV signing keys
3. Users generate proofs with valid mDL credentials
4. The ZK circuit enforces `addressBinding == hash(nullifier, bound_address)`

### Limitations

- This audit does not guarantee the absence of vulnerabilities
- AI-assisted analysis may miss subtle or novel attack vectors
- The ZK circuit itself was not audited in this report (see separate circuit audit)
- Economic/game-theoretic attacks may require specialized analysis

---

## Findings Summary

| ID | Title | Severity | Status | SWC |
|----|-------|----------|--------|-----|
| [M-01] | getTopDapps function can cause DoS via unbounded gas | Medium | Open | SWC-128 |
| [M-02] | Date calculation approximation can cause off-by-one errors | Medium | Open | - |
| [M-03] | Overpayment in mint/renew is not refunded | Medium | Open | - |
| [L-01] | No upper bound on mint/renewal prices | Low | Open | - |
| [L-02] | registeredDapps array can grow unboundedly | Low | Open | SWC-128 |
| [L-03] | IHonkVerifier.verify should be view but is not | Low | Open | - |
| [I-01] | Duplicate interface file ThurinSBT.sol in interfaces | Info | Open | - |
| [I-02] | THURIN_SBT constant is set to address(0) | Info | Open | - |
| [I-03] | Missing indexed parameters in events | Info | Open | - |
| [I-04] | Centralization risk: Owner can remove all IACA roots | Info | Open | - |
| [I-05] | ThurinPoints owner has no functional purpose | Info | Open | - |

---

## Detailed Findings

### [M-01] getTopDapps function can cause DoS via unbounded gas

**Severity**: Medium

**SWC**: SWC-128

**Location**: `contracts/src/ThurinPoints.sol:153-186`

#### Description

The `getTopDapps()` function uses a nested loop with O(n * limit) complexity, where n is the number of registered dApps. For each position in the result array, it iterates through all registered dApps to find the maximum. As the number of registered dApps grows, this function could exceed block gas limits.

```solidity
for (uint256 i = 0; i < limit; i++) {
    uint256 maxIdx = 0;
    uint256 maxVal = 0;

    for (uint256 j = 0; j < count; j++) {
        if (!used[j]) {
            uint256 val = verifier.dappVerificationCount(registeredDapps[j]);
            // ...
        }
    }
    // ...
}
```

#### Impact

- View function becomes uncallable when too many dApps register
- Any contract relying on this function will fail
- UI/frontend integrations will break

#### Recommendation

1. Add a maximum limit to the `limit` parameter
2. Consider off-chain sorting with on-chain verification
3. Use a heap or sorted linked list data structure for O(log n) operations

```solidity
function getTopDapps(uint256 limit) external view returns (
    address[] memory dapps,
    uint256[] memory verifications
) {
    uint256 count = registeredDapps.length;
    require(limit <= 100, "Limit too high"); // Add cap
    if (limit > count) limit = count;
    // ...
}
```

#### Verification Test

```solidity
function test_getTopDapps_DoSWithManyDapps() public {
    // Register many dApps
    for (uint256 i = 0; i < 1000; i++) {
        address dapp = address(uint160(i + 1000));
        vm.prank(dapp);
        points.registerDapp(string(abi.encodePacked("Dapp", i)));
    }

    // This should not revert due to gas
    uint256 gasBefore = gasleft();
    points.getTopDapps(10);
    uint256 gasUsed = gasBefore - gasleft();

    // Assert reasonable gas usage
    assertLt(gasUsed, 1_000_000, "Gas usage too high");
}
```

---

### [M-02] Date calculation approximation can cause off-by-one errors

**Severity**: Medium

**Location**: `contracts/src/ThurinSBT.sol:97-110`, `contracts/src/ThurinVerifier.sol:30-54`

#### Description

The `_timestampToYYYYMMDD()` function uses an approximate calculation that assumes 30-day months and 365-day years. This can cause the calculated date to differ from the actual date by 1-2 days, especially near year boundaries and month boundaries.

```solidity
function _timestampToYYYYMMDD(uint256 timestamp) internal pure returns (uint32) {
    uint256 daysSinceEpoch = timestamp / 86400;
    uint256 daysSince2020 = daysSinceEpoch > 18262 ? daysSinceEpoch - 18262 : 0;
    uint256 yearsSince2020 = daysSince2020 / 365; // Ignores leap years
    // ...
    uint256 month = (dayOfYear / 30) + 1; // All months treated as 30 days
    uint256 day = (dayOfYear % 30) + 1;
    // ...
}
```

#### Impact

- Users may have proofs rejected as "too old" or "from the future" when they are actually valid
- The 1-day tolerance (`PROOF_DATE_TOLERANCE_DAYS = 1`) may not be sufficient to cover calculation errors
- Edge cases around December/January could cause issues

#### Recommendation

1. Increase `PROOF_DATE_TOLERANCE_DAYS` to 2 to account for calculation errors
2. Or implement proper date calculation using a library like BokkyPooBahsDateTimeLibrary

```solidity
uint256 public constant PROOF_DATE_TOLERANCE_DAYS = 2; // Increased tolerance
```

#### Verification Test

```solidity
function test_timestampToYYYYMMDD_leapYear() public {
    // Feb 29, 2024 (leap year)
    uint256 feb29_2024 = 1709164800;
    vm.warp(feb29_2024);

    // The approximate formula may calculate this incorrectly
    uint32 calculated = sbt._timestampToYYYYMMDD(feb29_2024);
    // Expected: 20240229, but may get 20240228 or 20240301
}
```

---

### [M-03] Overpayment in mint/renew is not refunded

**Severity**: Medium

**Location**: `contracts/src/ThurinSBT.sol:184-236`, `contracts/src/ThurinSBT.sol:325-365`

#### Description

Both `mint()` and `renew()` functions check that `msg.value >= price` but do not refund any excess payment. Users who accidentally send more ETH than required will lose the difference.

```solidity
function mint(...) external payable returns (uint256) {
    // ...
    if (msg.value < getMintPrice()) revert InsufficientPayment();
    // No refund of excess
    // ...
}
```

#### Impact

- Users who send excess ETH lose funds permanently
- Particularly problematic if price changes between transaction submission and execution
- Poor UX that could damage user trust

#### Recommendation

Refund excess payment at the end of the function:

```solidity
function mint(...) external payable returns (uint256) {
    uint256 price = getMintPrice();
    if (msg.value < price) revert InsufficientPayment();

    // ... existing logic ...

    // Refund excess payment
    if (msg.value > price) {
        (bool success, ) = payable(msg.sender).call{value: msg.value - price}("");
        require(success, "Refund failed");
    }

    return tokenId;
}
```

#### Verification Test

```solidity
function test_mint_refundsExcess() public {
    bytes32 nullifier = keccak256("alice-nullifier");
    uint256 price = sbt.getMintPrice();
    uint256 excess = 0.1 ether;
    uint256 balanceBefore = alice.balance;

    vm.prank(alice);
    sbt.mint{value: price + excess}(
        MOCK_PROOF, nullifier, MOCK_ADDRESS_BINDING, PROOF_DATE, EVENT_ID, IACA_ROOT_CA,
        PROVE_AGE_21, PROVE_AGE_18, PROVE_STATE, STATE_CA, NO_REFERRER
    );

    // User should get excess refunded
    assertEq(alice.balance, balanceBefore - price, "Excess not refunded");
}
```

---

### [L-01] No upper bound on mint/renewal prices

**Severity**: Low

**Location**: `contracts/src/ThurinSBT.sol:394-405`

#### Description

The `setMintPrice()` and `setRenewalPrice()` functions allow the owner to set arbitrarily high prices without any upper bound. A malicious or compromised owner could set prices so high that minting/renewal becomes practically impossible.

```solidity
function setMintPrice(uint256 _mintPrice) external onlyOwner {
    uint256 oldPrice = mintPrice;
    mintPrice = _mintPrice; // No upper bound check
    emit MintPriceUpdated(oldPrice, _mintPrice);
}
```

#### Impact

- Centralization risk if owner is compromised
- Could effectively freeze new minting
- Users cannot predict pricing

#### Recommendation

Add reasonable upper bounds:

```solidity
uint256 public constant MAX_MINT_PRICE = 0.1 ether; // ~$300 at current prices

function setMintPrice(uint256 _mintPrice) external onlyOwner {
    require(_mintPrice <= MAX_MINT_PRICE, "Price too high");
    // ...
}
```

---

### [L-02] registeredDapps array can grow unboundedly

**Severity**: Low

**SWC**: SWC-128

**Location**: `contracts/src/ThurinPoints.sol:116`

#### Description

The `registeredDapps` array grows with each new dApp registration and is never pruned. While registration is permissionless, this could lead to storage bloat over time.

```solidity
function registerDapp(string calldata name) external {
    // ...
    registeredDapps.push(msg.sender); // Unbounded growth
    // ...
}
```

#### Impact

- Storage costs increase over time
- Functions iterating over this array become more expensive
- No mechanism to remove inactive dApps

#### Recommendation

Consider adding a mechanism for dApps to unregister, or implement pagination for enumeration functions.

---

### [L-03] IHonkVerifier.verify should be view but is not

**Severity**: Low

**Location**: `contracts/src/interfaces/IHonkVerifier.sol:11-14`

#### Description

The `IHonkVerifier.verify()` function is declared without the `view` modifier, but the actual HonkVerifier implementation appears to be a pure verification function that doesn't modify state.

```solidity
interface IHonkVerifier {
    function verify(
        bytes calldata proof,
        bytes32[] calldata publicInputs
    ) external returns (bool); // Missing 'view'
}
```

#### Impact

- Callers cannot use this function in read-only contexts
- May prevent optimizations by the compiler
- Interface doesn't accurately reflect implementation behavior

#### Recommendation

If the HonkVerifier implementation is indeed stateless, update the interface:

```solidity
function verify(
    bytes calldata proof,
    bytes32[] calldata publicInputs
) external view returns (bool);
```

---

### [I-01] Duplicate interface file ThurinSBT.sol in interfaces

**Severity**: Informational

**Location**: `contracts/src/interfaces/ThurinSBT.sol`

#### Description

There is both an `IThurinSBT.sol` interface and a `ThurinSBT.sol` library file in the interfaces directory. The library wraps calls to a hardcoded address that is currently set to `address(0)`.

#### Recommendation

Remove the library file or move it to a separate directory to avoid confusion. The library will also fail at runtime since `THURIN_SBT` is `address(0)`.

---

### [I-02] THURIN_SBT constant is set to address(0)

**Severity**: Informational

**Location**: `contracts/src/interfaces/IThurinSBT.sol:5`

#### Description

The `THURIN_SBT` constant is set to `address(0)`, which will cause the ThurinSBT library to fail when used.

```solidity
address constant THURIN_SBT = address(0); // TODO: Set after deployment
```

#### Recommendation

Update this constant after deployment, or consider using an initializable pattern if the address needs to be set dynamically.

---

### [I-03] Missing indexed parameters in events

**Severity**: Informational

**Location**: Various

#### Description

Some events could benefit from additional indexed parameters for better filtering:
- `MintPriceUpdated` - consider indexing newPrice
- `RenewalPriceUpdated` - consider indexing newPrice
- `DappPointsClaimed` - consider indexing points amount

#### Recommendation

Add indexed modifiers to frequently queried event parameters for better off-chain indexing.

---

### [I-04] Centralization risk: Owner can remove all IACA roots

**Severity**: Informational

**Location**: `contracts/src/ThurinSBT.sol:387-391`

#### Description

The owner can remove all trusted IACA roots, effectively preventing anyone from minting new SBTs or renewing existing ones. While the Ownable2Step pattern provides some protection, this remains a centralization risk.

#### Recommendation

Consider:
1. Timelock for IACA root removal
2. Multi-sig requirement for critical operations
3. Minimum number of trusted roots requirement

---

### [I-05] ThurinPoints owner has no functional purpose

**Severity**: Informational

**Location**: `contracts/src/ThurinPoints.sol`

#### Description

The ThurinPoints contract inherits Ownable2Step but the owner has no special capabilities - there are no admin functions that use the onlyOwner modifier.

#### Recommendation

Either remove the Ownable2Step inheritance to save gas, or add documentation explaining future governance intentions.

---

## Security Positive Findings

The following security best practices were correctly implemented:

### 1. Access Control
- **Ownable2Step**: Two-step ownership transfer pattern used to prevent accidental ownership transfers
- **Proper modifiers**: `onlyOwner` correctly applied to all admin functions
- **No tx.origin usage**: Authentication uses msg.sender throughout

### 2. Reentrancy Protection
- **CEI Pattern**: Checks-Effects-Interactions pattern followed in mint/renew functions
- **State updates before external calls**: Nullifier marked used before calling ERC721 _safeMint
- **Withdraw pattern**: Uses low-level call with success check for ETH withdrawal

### 3. Soulbound Implementation
- **Transfer restriction**: _update override correctly prevents all transfers except mint/burn
- **Proper error handling**: Custom `Soulbound` error for clear failure messaging

### 4. Sybil Resistance
- **Nullifier tracking**: Proper mapping to prevent double-minting with same credential
- **Referral protection**: Self-referral check prevents point manipulation

### 5. ZK Integration
- **Trusted roots**: IACA root whitelist prevents unauthorized proof acceptance
- **Proof freshness**: Timestamp validation prevents stale proof replay
- **Address binding**: Public input bound_address passed to ZK verifier for front-running protection

---

## Verification Plan

### Tests to Add

| Finding | Test Description | Priority |
|---------|-----------------|----------|
| [M-01] | Test getTopDapps gas usage with many dApps | High |
| [M-02] | Test date calculation edge cases (leap years, month boundaries) | Medium |
| [M-03] | Test that overpayment is handled correctly | Medium |

### Invariants to Enforce

```solidity
// Suggested invariant tests

function invariant_NullifierCanOnlyBeUsedOnce() public {
    // A nullifier marked as used should never be unmarked
    // Total SBT supply should equal number of unique nullifiers used
}

function invariant_SBTSupplyMatchesTokenIds() public {
    // totalSupply() should equal _tokenIdCounter
    // Each tokenId from 0 to totalSupply()-1 should have an owner
}

function invariant_PointsNeverDecrease() public {
    // User points should be monotonically increasing (no burn mechanism)
    // dApp points should be monotonically increasing
}

function invariant_OnlyValidSBTHoldersCanRenew() public {
    // renew() should only succeed for addresses with balanceOf() > 0
}
```

### Monitoring Recommendations

| Metric | Alert Threshold | Rationale |
|--------|----------------|-----------|
| Owner changes | Any | Detect unauthorized ownership transfers |
| IACA root removals | Any | Critical security parameter changes |
| Large withdrawals | >10 ETH | Detect potential compromise |
| High gas usage in getTopDapps | >500k gas | Approaching DoS threshold |
| Unusual minting patterns | >100/hour | Potential bot activity |

---

## Appendix

### A. Tools Used

- Foundry 0.8.28 (build & test)
- Manual code review

### B. SWC References

| SWC | Title | Findings |
|-----|-------|----------|
| SWC-128 | DoS With Block Gas Limit | [M-01], [L-02] |

### C. Test Results

All 82 tests passed:
- ThurinSBT.t.sol: 47 tests
- ThurinVerifier.t.sol: 16 tests
- ThurinPoints.t.sol: 16 tests
- Integration.t.sol: 3 tests

### D. Contract Sizes

| Contract | Size (bytes) | EIP-170 Limit |
|----------|-------------|---------------|
| ThurinSBT | ~15,000 | 24,576 (OK) |
| ThurinVerifier | ~3,500 | 24,576 (OK) |
| ThurinPoints | ~5,000 | 24,576 (OK) |
| HonkVerifier | ~24,641 | 24,576 (EXCEEDS) |

Note: HonkVerifier exceeds EIP-170 limit. Requires `--code-size-limit` flag for deployment on non-mainnet or L2 chains with higher limits.

### E. Disclosure

This audit was performed by Claude Opus 4.5, an AI assistant. While comprehensive automated and manual analysis was performed, AI-assisted audits should be supplemented with human expert review for critical deployments.

---

*Generated by Solidity Audit Assistant*
